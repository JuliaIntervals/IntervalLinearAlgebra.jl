<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear systems · IntervalLinearAlgebra.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://juliaintervals.github.io/IntervalLinearAlgebra.jl/tutorials/linear_systems/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><script src="../../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="IntervalLinearAlgebra.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">IntervalLinearAlgebra.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Linear systems</a><ul class="internal"><li><a class="tocitem" href="#Solve-interval-linear-systems"><span>Solve interval linear systems</span></a></li><li><a class="tocitem" href="#Verify-real-linear-systems"><span>Verify real linear systems</span></a></li></ul></li><li><a class="tocitem" href="../eigenvalues/">Eigenvalue computations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../applications/FEM_example/">Interval FEM</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Explanations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../explanations/solution_set/">Interval system solution set</a></li><li><a class="tocitem" href="../../explanations/preconditioning/">Preconditioning</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/classify/">Interval matrices classification</a></li><li><a class="tocitem" href="../../api/solve/">Solver interface</a></li><li><a class="tocitem" href="../../api/algorithms/">Interval linear systems</a></li><li><a class="tocitem" href="../../api/precondition/">Preconditioners</a></li><li><a class="tocitem" href="../../api/epsilon_inflation/">Verified real linear systems</a></li><li><a class="tocitem" href="../../api/eigenvalues/">Eigenvalues</a></li><li><a class="tocitem" href="../../api/misc/">Miscellaneous</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../CONTRIBUTING/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Linear systems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Linear systems</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaIntervals/IntervalLinearAlgebra.jl/blob/master/docs/src/tutorials/linear_systems.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Linear-systems"><a class="docs-heading-anchor" href="#Linear-systems">Linear systems</a><a id="Linear-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-systems" title="Permalink"></a></h1><ul><li><a href="#Linear-systems">Linear systems</a></li><li class="no-marker"><ul><li><a href="#Solve-interval-linear-systems">Solve interval linear systems</a></li><li><a href="#Verify-real-linear-systems">Verify real linear systems</a></li></ul></li></ul><p>This tutorial will show you how to solve linear systems rigorously using <code>IntervalLinearAlgebra.jl</code>.</p><h2 id="Solve-interval-linear-systems"><a class="docs-heading-anchor" href="#Solve-interval-linear-systems">Solve interval linear systems</a><a id="Solve-interval-linear-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-interval-linear-systems" title="Permalink"></a></h2><p>An interval linear system <span>$\mathbf{Ax}=\mathbf{b}$</span> is a linear system where <span>$\mathbf{A}$</span> and <span>$\mathbf{b}$</span> contain intervals. In general, the solution set <span>$\mathbf{x}$</span> can have a complex non-convex shape and can thus be hard to characterize exactly (see <a href="../../explanations/solution_set/">this article</a> for more details). Hence we are interested in finding an interval box containing <span>$\mathbf{x}$</span>. In <code>IntervalLinearAlgebra.jl</code>, this is achieved through the <code>solve</code> function, which gives a handy interface to choose the algorithm and preconditioning mechanism. The syntax to call solve is </p><pre><code class="language-julia hljs">solve(A, b, method, precondition)</code></pre><ul><li><span>$A$</span> is an interval matrix</li><li><span>$b$</span> is an interval vector</li><li><code>method</code> is an optional parameter to choose the algorithm used to solve the interval linear system, see below for more details</li><li><code>precondition</code> is an optional parameter to choose the preconditioning for the problem. More details about preconditoining can be found <a href="../../explanations/preconditioning/">here</a></li></ul><h3 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h3><p>The supported methods are</p><ul><li><p>Direct solvers</p><ul><li><a href="../../api/algorithms/#IntervalLinearAlgebra.GaussianElimination"><code>GaussianElimination</code></a></li><li><a href="../../api/algorithms/#IntervalLinearAlgebra.HansenBliekRohn"><code>HansenBliekRohn</code></a></li><li><a href="../../api/algorithms/#IntervalLinearAlgebra.LinearOettliPrager"><code>LinearOettliPrager</code></a> (requires importing LazySets.jl)</li></ul></li><li><p>Iterative solvers</p><ul><li><a href="../../api/algorithms/#IntervalLinearAlgebra.LinearKrawczyk"><code>LinearKrawczyk</code></a></li><li><a href="../../api/algorithms/#IntervalLinearAlgebra.Jacobi"><code>Jacobi</code></a></li><li><a href="../../api/algorithms/#IntervalLinearAlgebra.GaussSeidel"><code>GaussSeidel</code></a></li><li><a href="../../api/algorithms/#IntervalLinearAlgebra.NonLinearOettliPrager"><code>NonLinearOettliPrager</code></a> (requires importing IntervalConstraintProgramming.jl)</li></ul></li></ul><p><code>LinearOettliPrager</code> and <code>NonLinearOettliPrager</code> are &quot;special&quot; in the sense that they try to exactly characterize the solution set using Oettli-Präger and are not considered in this tutorial. More information about them can be found <a href="../../explanations/solution_set/">here</a>. The other solvers return a vector of intervals, representing an interval enclosure of the solution set. If the method is not specified, Gaussian elimination is used by default.</p><h3 id="Preconditioning"><a class="docs-heading-anchor" href="#Preconditioning">Preconditioning</a><a id="Preconditioning-1"></a><a class="docs-heading-anchor-permalink" href="#Preconditioning" title="Permalink"></a></h3><p>The supported preconditioning mechanisms are</p><ul><li><a href="../../api/precondition/#IntervalLinearAlgebra.NoPrecondition"><code>NoPrecondition</code></a></li><li><a href="../../api/precondition/#IntervalLinearAlgebra.InverseMidpoint"><code>InverseMidpoint</code></a></li><li><a href="../../api/precondition/#IntervalLinearAlgebra.InverseDiagonalMidpoint"><code>InverseDiagonalMidpoint</code></a></li></ul><p>If preconditioning is not specified, then an heuristic strategy based on the type of matrix and solver is used to choose the preconditioning. The strategy is discussed at the end of the <a href="../../explanations/preconditioning/">preconditioning tutorial</a>.</p><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><p>We now demonstrate a few examples using the solve function, these examples are taken from <a href="../../references/#[HOR19]">[HOR19]</a>.</p><pre><code class="language-julia hljs">using IntervalLinearAlgebra

A = [4..6 -1..1 -1..1 -1..1;-1..1 -6.. -4 -1..1 -1..1;-1..1 -1..1 9..11 -1..1;-1..1 -1..1 -1..1 -11.. -9]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×4 Matrix{Interval{Float64}}:
  [4, 6]   [-1, 1]  [-1, 1]    [-1, 1]
 [-1, 1]  [-6, -4]  [-1, 1]    [-1, 1]
 [-1, 1]   [-1, 1]  [9, 11]    [-1, 1]
 [-1, 1]   [-1, 1]  [-1, 1]  [-11, -9]</code></pre><pre><code class="language-julia hljs">b = [-2..4, 1..8, -4..10, 2..12]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Interval{Float64}}:
  [-2, 4]
   [1, 8]
 [-4, 10]
  [2, 12]</code></pre><pre><code class="language-julia hljs">solve(A, b, HansenBliekRohn())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Interval{Float64}}:
 [-2.50001, 3.10001]
 [-3.90001, 1.20001]
 [-1.40001, 2.15001]
 [-2.35001, 0.600001]</code></pre><pre><code class="language-julia hljs">solve(A, b, GaussianElimination())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Interval{Float64}}:
 [-2.60001, 3.10001]
 [-3.90001, 1.50001]
 [-1.43001, 2.15001]
 [-2.35001, 0.600001]</code></pre><pre><code class="language-julia hljs">solve(A, b, GaussSeidel())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Interval{Float64}}:
 [-2.60001, 3.10001]
 [-3.90001, 1.65001]
 [-1.48334, 2.15001]
 [-2.35001, 0.794445]</code></pre><p>For iterative methods, an additional optional parameter <code>X0</code> representing an initial guess for the solution&#39;s enclosure can be given. If not given, a rough initial enclosure is computed using the <a href="../../api/misc/#IntervalLinearAlgebra.enclose-Union{Tuple{T}, Tuple{N}, Tuple{StaticArrays.StaticMatrix{N, N, T}, StaticArrays.StaticVector{N, T}}} where {N, T&lt;:Interval}"><code>enclose</code></a> function.</p><pre><code class="language-julia hljs">X0 = fill(-5..5, 4)
solve(A, b, GaussSeidel(), InverseMidpoint(), X0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Interval{Float64}}:
 [-2.60001, 3.10001]
 [-3.90001, 1.65001]
 [-1.48334, 2.15001]
 [-2.35001, 0.794445]</code></pre><h2 id="Verify-real-linear-systems"><a class="docs-heading-anchor" href="#Verify-real-linear-systems">Verify real linear systems</a><a id="Verify-real-linear-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Verify-real-linear-systems" title="Permalink"></a></h2><p><code>IntervalLinearAlgebra.jl</code> also offers functionalities to solve real linear systems rigorously. It is of course possible to just convert the real system to an interval system and use the methods described above. In this situation, however, the system will have the property where the diameters of the intervals will be very small (zero or a few floating point units). To solve these kind of systems, it can be more efficient to use the <em>epsilon inflation</em> method <a href="../../references/#[RUM10]">[RUM10]</a>, especially for bigger matrices. Here is an example</p><pre><code class="language-julia hljs">A = [1.0 2;3 4]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 1.0  2.0
 3.0  4.0</code></pre><pre><code class="language-julia hljs">b = [3, 7]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Int64}:
 3
 7</code></pre><p>the real linear system <span>$Ax=b$</span> can now be solved <em>rigorously</em> using the <a href="../../api/epsilon_inflation/#IntervalLinearAlgebra.epsilon_inflation-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractArray{S, N}}} where {T&lt;:Real, S&lt;:Real, N}"><code>epsilon_inflation</code></a> function.</p><pre><code class="language-julia hljs">x, cert = epsilon_inflation(A, b)
@show cert
x</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Interval{Float64}}:
 [0.999999, 1.00001]
 [0.999999, 1.00001]</code></pre><p>This function returns two values: an interval vector <code>x</code> and a boolean certificate <code>cert</code>. If <code>cert==true</code> then <code>x</code> is guaranteed to be an enclosure of the real linear system <code>Ax=b</code>. If <code>cert == false</code> then the algorithm could not verify that the enclosure is rigorous, i.e. it may or may not contain the true solution.</p><p>In the following example the epsilon inflation method returns a non-rigorous bound</p><pre><code class="language-julia hljs">A1 = [1..1+1e-16 2;3 4]
x1, cert = epsilon_inflation(A1, b)
@show cert
x1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Interval{Float64}}:
 [0.999999, 1.00001]
 [0.999999, 1.00001]</code></pre><p>Since the matrix <code>A1</code> is non-regular (it contains the matrix <span>$\begin{bmatrix}1&amp;2\\3&amp;4\end{bmatrix}$</span> which is singluar), the solution set is unbounded, hence the algorithm could not prove (rightly) that <code>x1</code> is an enclosure of the true solution. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../eigenvalues/">Eigenvalue computations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Sunday 30 January 2022 13:35">Sunday 30 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
