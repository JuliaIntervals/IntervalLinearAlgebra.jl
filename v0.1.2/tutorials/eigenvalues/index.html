<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Eigenvalue computations · IntervalLinearAlgebra.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://juliaintervals.github.io/IntervalLinearAlgebra.jl/tutorials/eigenvalues/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="IntervalLinearAlgebra.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">IntervalLinearAlgebra.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../linear_systems/">Linear systems</a></li><li class="is-active"><a class="tocitem" href>Eigenvalue computations</a><ul class="internal"><li><a class="tocitem" href="#Eigenvalues-of-interval-matrices"><span>Eigenvalues of interval matrices</span></a></li><li><a class="tocitem" href="#Verified-floating-point-computations-of-eigenvalues"><span>Verified floating point computations of eigenvalues</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../wip/">Applications</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Explanations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../explanations/solution_set/">Interval system solution set</a></li><li><a class="tocitem" href="../../explanations/preconditioning/">Preconditioning</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/classify/">Interval matrices classification</a></li><li><a class="tocitem" href="../../api/solve/">Solver interface</a></li><li><a class="tocitem" href="../../api/algorithms/">Interval linear systems</a></li><li><a class="tocitem" href="../../api/precondition/">Preconditioners</a></li><li><a class="tocitem" href="../../api/epsilon_inflation/">Verified real linear systems</a></li><li><a class="tocitem" href="../../api/eigenvalues/">Eigenvalues</a></li><li><a class="tocitem" href="../../api/misc/">Miscellaneous</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../CONTRIBUTING/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Eigenvalue computations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Eigenvalue computations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaIntervals/IntervalLinearAlgebra.jl/blob/master/docs/src/tutorials/eigenvalues.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Eigenvalue-computations"><a class="docs-heading-anchor" href="#Eigenvalue-computations">Eigenvalue computations</a><a id="Eigenvalue-computations-1"></a><a class="docs-heading-anchor-permalink" href="#Eigenvalue-computations" title="Permalink"></a></h1><h2 id="Eigenvalues-of-interval-matrices"><a class="docs-heading-anchor" href="#Eigenvalues-of-interval-matrices">Eigenvalues of interval matrices</a><a id="Eigenvalues-of-interval-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Eigenvalues-of-interval-matrices" title="Permalink"></a></h2><p>Given a (real or complex) interval matrix <span>$A\in\mathbb{IC}^{n\times n}$</span>, we define the eigenvalue set </p><p class="math-container">\[\mathbf{\Lambda}=\{\lambda\in\mathbb{C}: \lambda\text{ is an eigenvalue of }A\text{ for some }A\in\mathbf{A}\}.\]</p><p>While characterizing the solution set <span>$\mathbf{\Lambda}$</span> (or even its hull) is computationally challenging, the package offers the function <a href="../../api/eigenvalues/#IntervalLinearAlgebra.eigenbox-Union{Tuple{T}, Tuple{Symmetric{Interval{T}, Array{Interval{T}, 2}}, Rohn}} where T"><code>eigenbox</code></a> which contains an interval box containing <span>$\mathbf{\Lambda}$</span>. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>At the moment, <code>eigenbox</code> is not rigorous, that is the computations for the non-interval eigenvalue problem solved internally are carried out using normal non-verified floating point computations.</p></div></div><p>To demonstrate the functionality, let us consider the following interval matrix</p><pre><code class="language-julia hljs">using IntervalLinearAlgebra

A = [-3.. -2 4..5 4..6 -1..1.5;
    -4.. -3 -4.. -3 -4.. -3 1..2;
    -5.. -4 2..3 -5.. -4 -1..0;
    -1..0.1 0..1 1..2 -4..2.5]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×4 Matrix{Interval{Float64}}:
 [-3, -2]            [4, 5]    [4, 6]   [-1, 1.5]
 [-4, -3]          [-4, -3]  [-4, -3]   [1, 2]
 [-5, -4]            [2, 3]  [-5, -4]  [-1, 0]
   [-1, 0.100001]    [0, 1]    [1, 2]   [-4, 2.5]</code></pre><p>Now we can bound the eigenvalue set</p><pre><code class="language-julia hljs">ebox = eigenbox(A)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[-8.8221, 3.4408] + [-10.7497, 10.7497]im</code></pre><p>To get a qualitative evaluation of the enclosure, we can simulate the solution set of <span>$\mathbf{A}$</span> using Montecarlo, as it is done in the following example</p><pre><code class="language-julia hljs">using Plots
N = 1000

evalues = zeros(ComplexF64, 4, N)

for i in 1:N
    evalues[:, i] = eigvals(rand.(A))
end

rpart = real.(evalues)
ipart = imag.(evalues)

plot(IntervalBox(real(ebox), imag(ebox)); ratio=1, label=&quot;enclosure&quot;)
scatter!(rpart[1, :], ipart[1, :]; label=&quot;λ₁&quot;)
scatter!(rpart[2, :], ipart[2, :]; label=&quot;λ₂&quot;)
scatter!(rpart[3, :], ipart[3, :]; label=&quot;λ₃&quot;)
scatter!(rpart[4, :], ipart[4, :]; label=&quot;λ₄&quot;)
xlabel!(&quot;real&quot;)
ylabel!(&quot;imag&quot;)</code></pre><p><img src="../eigs.png" alt/></p><p>Internally, the generical interval eigenvalue problem is reduced to a real symmetric interval eigenvalue problem, as described in <a href="../../references/#[HLA13]">[HLA13]</a>. It is good to remind that a real symmetric matrix has only real eigenvalues. The real symmetric interval eigenvalue problem can be solved in two ways</p><ul><li>Rohn method – (default one) computes an enclosure of the eigenvalues set for the symmetric interval matrix. This is fast but the enclosure can be strictly larger than the hull</li><li>Hertz method – computes the exact hull of the eigenvalues for the symmetric interval matrix. Generally, these leads to tigher bounds, but it has exponential complexity, so it will be unfeasible for big matrices.</li></ul><p>The function <code>eigenbox</code> can take a second optional parameter (Rohn() by default) to specify what algorithm to use for the real symmetric interval eigenvalue problem. The following example bounds the eigenvalues of the previous matrix using Hertz(), as can be noticed by the figure below, the Hertz method gives a tighter bound on the eigenvalues set.</p><pre><code class="language-julia hljs">eboxhertz = eigenbox(A, Hertz())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[-7.36904, 3.2742] + [-8.79471, 8.79471]im</code></pre><pre><code class="language-julia hljs">plot(IntervalBox(real(ebox), imag(ebox)); ratio=1, label=&quot;enclosure&quot;)
xlabel!(&quot;real&quot;)
ylabel!(&quot;imag&quot;)</code></pre><p><img src="../eigs2.png" alt/></p><h2 id="Verified-floating-point-computations-of-eigenvalues"><a class="docs-heading-anchor" href="#Verified-floating-point-computations-of-eigenvalues">Verified floating point computations of eigenvalues</a><a id="Verified-floating-point-computations-of-eigenvalues-1"></a><a class="docs-heading-anchor-permalink" href="#Verified-floating-point-computations-of-eigenvalues" title="Permalink"></a></h2><p>In the previous section we considered the problem of finding the eigenvalue set (or an enclosure of it) of an interval matrix. In this section, we consider the problem of computing eigenvalues and eigenvectors of a floating point matrix <em>rigorously</em>, that is we want to find an enclosure of the true eigenvalues and eigenvectors of the matrix. In <code>IntervalLinearAlgebra.jl</code> this is achieved using the <a href="../../api/eigenvalues/#IntervalLinearAlgebra.verify_eigen-Tuple{Any}"><code>verify_eigen</code></a> function, as the following example demonstrates.</p><pre><code class="language-julia hljs">A = [1 2; 3 4]
evals, evecs, cert = verify_eigen(A)
evals</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Complex{Interval{Float64}}}:
 [-0.372282, -0.372281] + [-3.92467e-16, 3.92467e-16]im
     [5.37228, 5.37229] + [-2.5503e-16, 2.5503e-16]im</code></pre><pre><code class="language-julia hljs">evecs</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Complex{Interval{Float64}}}:
  [-0.824565, -0.824564] + [0, 0]im                    …  [-0.415974, -0.415973] + [-4.31e-33, 4.31e-33]im
 [0.565767, 0.565768] + [-4.95531e-33, 4.95531e-33]im        [-0.909377, -0.909376] + [0, 0]im</code></pre><pre><code class="language-julia hljs">cert</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Bool}:
 1
 1</code></pre><p>If called with only one input <code>verify_eigen</code> will first compute an approximate solution for the eigenvalues and eigenvectors of <span>$A$</span> and use that to find a rigorous bounding on the true eigenvalues and eigenvectors of the matrix. It is also possible to give the function the scalar parameters <span>$\lambda$</span> and <span>$\vec{v}$</span>, in which case it will compute a rigorous bound only for the specified eigenvalue <span>$\lambda$</span> and eigenvector <span>$\vec{v}$</span>. The last output of the function is a vector of boolean certificates, if the <span>$i$</span>th element is set to true, then the enclosure of the <span>$i$</span>th eigenvalue and eigenvector is rigorous, that is the algorithm could prove that that enclosure contains the true eigenvalue and eigenvector of <span>$A$</span>. If the certificate is false, then the algorithm could not prove the validity of the enclosure.</p><p>The function also accepts interval inputs. This is handy if the input matrix elements cannot be represented exactly as floating point numbers. Note however that this is meant only for interval matrices with very small intervals. If you have larger intervals, you should use the function of the previous section.</p><p>To test the function, let us consider the following example. First we generate random eigenvalues and eigenvectors</p><pre><code class="language-julia hljs">ev = sort(randn(5))
D = Diagonal(ev)
P = randn(5, 5)
Pinv, _ = epsilon_inflation(P, Diagonal(ones(5)))
A = interval.(P) * D * Pinv</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5×5 Matrix{Interval{Float64}}:
 [-0.517837, -0.517836]  [-0.908445, -0.908444]  …  [-1.06095, -1.06094]
 [-0.915597, -0.915596]  [-0.867942, -0.867941]     [-2.08626, -2.08625]
 [-0.41798, -0.417979]   [-0.513929, -0.513928]     [-0.714897, -0.714896]
  [0.302862, 0.302863]   [-0.524724, -0.524723]     [-1.03491, -1.0349]
  [0.800493, 0.800494]    [0.132962, 0.132963]       [0.44774, 0.447741]</code></pre><p>Now we obtained an interval matrix <span>$\mathbf{A}$</span> so that <code>ev</code> and <code>P</code> are eigenvalues and eigenvectors of some <span>$A\in\mathbf{A}$</span>. Note that <span>$P^{-1}$</span> had to be computed rigorously using <a href="../../api/epsilon_inflation/#IntervalLinearAlgebra.epsilon_inflation-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractArray{S, N}}} where {T&lt;:Real, S&lt;:Real, N}"><code>epsilon_inflation</code></a>. Now we can compute its eigenvalues and eigenvectors and verify that the enclosures contain the true values.</p><pre><code class="language-julia hljs">evals, evecs, cert = verify_eigen(A)
evals</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Complex{Interval{Float64}}}:
   [-0.523532, -0.523531] + [-2.13505e-14, 2.13505e-14]im
 [-0.0219385, -0.0219384] + [-1.82828e-14, 1.82828e-14]im
     [0.124972, 0.124973] + [-2.46438e-14, 2.46438e-14]im
      [0.597079, 0.59708] + [-9.35604e-15, 9.35604e-15]im
       [1.25766, 1.25767] + [-2.48506e-14, 2.48506e-14]im</code></pre><pre><code class="language-julia hljs">evecs</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5×5 Matrix{Complex{Interval{Float64}}}:
      [0.691573, 0.691574] + [0, 0]im                    …     [0.461508, 0.461509] + [-1.73249e-28, 1.73249e-28]im
    [0.34574, 0.345741] + [-6.74725e-28, 6.74725e-28]im           [0.718794, 0.718795] + [0, 0]im
     [0.364899, 0.3649] + [-1.51481e-28, 1.51481e-28]im        [0.260058, 0.260059] + [-6.93834e-29, 6.93834e-29]im
 [-0.278123, -0.278122] + [-3.51842e-28, 3.51842e-28]im        [0.440331, 0.440332] + [-1.66923e-28, 1.66923e-28]im
  [-0.437821, -0.43782] + [-3.68215e-28, 3.68215e-28]im     [-0.093926, -0.0939259] + [-1.29601e-28, 1.29601e-28]im</code></pre><pre><code class="language-julia hljs">cert</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Bool}:
 1
 1
 1
 1
 1</code></pre><pre><code class="language-julia hljs">ev .∈ evals</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element BitVector:
 1
 1
 1
 1
 1</code></pre><p>Note also that despite the original eigenvalues and eigenvectors were real, the returned enclosures are complex. This is because any infinitesimally small perturbation in the elements of <span>$A$</span> may cause the eigenvalues to move away from the real line. For this reason, unless the matrix has some special structure that guarantees the eigenvalues are real (e.g. symmetric matrices), a valid enclosure should always be complex.</p><p>Finally, the concept of enclosure of eigenvector may feel confusing, since eigenvectors are unique up to scale. This scale ambiguity is resolved by starting with the approximate eigenvector computed by normal linear algebra routines and fixing the element with the highest magnitude. </p><pre><code class="language-julia hljs">complex_diam(x) = max(diam(real(x)), diam(imag(x)))

complex_diam.(evecs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5×5 Matrix{Float64}:
 0.0          2.4114e-13   2.88769e-13  6.75848e-14  2.67564e-14
 5.35683e-14  0.0          0.0          0.0          0.0
 1.88738e-14  2.48912e-13  3.08253e-13  2.7138e-14   1.27121e-14
 3.11973e-14  1.18044e-13  1.41609e-13  5.61946e-14  2.31482e-14
 3.03646e-14  6.08541e-14  7.09433e-14  6.27831e-14  1.39472e-14</code></pre><p>As can be seen, for each eigenvector there&#39;s an interval with zero width, since to resolve scale ambiguity one non-zero element can be freely chosen (assuming eigenvalues have algebraic multiplicity <span>$1$</span>). After that, the eigenvector is fixed and it makes sense to talk about enclosures of the other elements.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../linear_systems/">« Linear systems</a><a class="docs-footer-nextpage" href="../../wip/">Applications »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.6 on <span class="colophon-date" title="Wednesday 22 September 2021 11:43">Wednesday 22 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
