var documenterSearchIndex = {"docs":
[{"location":"references/#all_ref","page":"References","title":"References","text":"","category":"section"},{"location":"references/#[HLA13]","page":"References","title":"[HLA13]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"M. Hladík. Bounds on eigenvalues of real and complex interval matrices. Appl. Math. Comput., 219(10):5584–5591, 2013.","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{Hla2013a,\n author = \"Milan Hlad\\'{\\i}k\",\n title = \"Bounds on eigenvalues of real and complex interval matrices\",\n journal = \"Appl. Math. Comput.\",\n fjournal = \"Applied Mathematics and Computation\",\n volume = \"219\",\n number = \"10\",\n pages = \"5584-5591\",\n year = \"2013\",\n issn = \"0096-3003\",\n doi = \"10.1016/j.amc.2012.11.075\",\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[HOR19]","page":"References","title":"[HOR19]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"J. Horácek, Interval Linear and Nonlinear Systems, PhD dissertation, 2019","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{horavcek2019interval,\n  title={Interval linear and nonlinear systems},\n  author={Hor{\\'a}{\\v{c}}ek, Jaroslav},\n  year={2019},\n  publisher={Univerzita Karlova, Matematicko-fyzik{\\'a}ln{\\'\\i} fakulta}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[JAU14]","page":"References","title":"[JAU14]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"L. Jaulin and B. Desrochers, Introduction to the algebra of separators with application to path planning, Engineering Applications of Artificial Intelligence 33 (2014): 141-147","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{jaulin2014introduction,\n  title={Introduction to the algebra of separators with application to path planning},\n  author={Jaulin, Luc and Desrochers, Beno{\\^\\i}t},\n  journal={Engineering Applications of Artificial Intelligence},\n  volume={33},\n  pages={141--147},\n  year={2014},\n  publisher={Elsevier}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[NEU90]","page":"References","title":"[NEU90]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"A. Neumaier, Interval methods for systems of equations, Cambridge university press, 1990 ","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@book{neumaier1990interval,\n  title={Interval methods for systems of equations},\n  author={Neumaier, Arnold and Neumaier, Arnold},\n  number={37},\n  year={1990},\n  publisher={Cambridge university press}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[OET64]","page":"References","title":"[OET64]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"W. Oettli and W. Prager, Compatibility of approximate solution of linear equa- tions with given error bounds for coefficients and right-hand sides, Numerische Mathematik, 6(1):405–409, 1964.","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{oettli1964compatibility,\n  title={Compatibility of approximate solution of linear equations with given error bounds for coefficients and right-hand sides},\n  author={Oettli, Werner and Prager, William},\n  journal={Numerische Mathematik},\n  volume={6},\n  number={1},\n  pages={405--409},\n  year={1964},\n  publisher={Springer}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[ROH06]","page":"References","title":"[ROH06]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"J. Rohn. Solvability of systems of interval linear equations and inequalities, Linear optimization problems with inexact data, pages 35–77. Springer, 2006","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@incollection{rohn2006solvability,\n  title={Solvability of systems of interval linear equations and inequalities},\n  author={Rohn, Jir{\\i}},\n  booktitle={Linear optimization problems with inexact data},\n  pages={35--77},\n  year={2006},\n  publisher={Springer}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[ROH95]","page":"References","title":"[ROH95]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"J. Rohn and V. Kreinovich. Computing exact componentwise bounds on solutions of lineary systems with interval data is NP-hard. SIAM Journal on Matrix Analysis and Applications, 16(2):415–420, 1995.","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{rohn1995computing,\n  title={Computing exact componentwise bounds on solutions of lineary systems with interval data is NP-hard},\n  author={Rohn, Jiri and Kreinovich, Vladik},\n  journal={SIAM Journal on Matrix Analysis and Applications},\n  volume={16},\n  number={2},\n  pages={415--420},\n  year={1995},\n  publisher={SIAM}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[RUM10]","page":"References","title":"[RUM10]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"S.M. Rump, Verification methods: Rigorous results using floating-point arithmetic, Acta Numerica, 19:287–449, 2010","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{rump2010verification,\n  title={Verification methods: Rigorous results using floating-point arithmetic},\n  author={Rump, Siegfried M},\n  journal={Acta Numerica},\n  volume={19},\n  pages={287--449},\n  year={2010},\n  publisher={Cambridge University Press}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[RUM01]","page":"References","title":"[RUM01]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"Rump, Siegfried M. Computational error bounds for multiple or nearly multiple eigenvalues, Linear algebra and its applications 324.1-3 (2001): 209-226.","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{rump2001computational,\n  title={Computational error bounds for multiple or nearly multiple eigenvalues},\n  author={Rump, Siegfried M},\n  journal={Linear algebra and its applications},\n  volume={324},\n  number={1-3},\n  pages={209--226},\n  year={2001},\n  publisher={Elsevier}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[RUM99]","page":"References","title":"[RUM99]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"Rump, Siegfried M. Fast and parallel interval arithmetic, BIT Numerical Mathematics 39.3, 534-554, 1999","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{rump1999fast,\n  title={Fast and parallel interval arithmetic},\n  author={Rump, Siegfried M},\n  journal={BIT Numerical Mathematics},\n  volume={39},\n  number={3},\n  pages={534--554},\n  year={1999},\n  publisher={Springer}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"api/eigenvalues/#Eigenvalues-computations","page":"Eigenvalues","title":"Eigenvalues computations","text":"","category":"section"},{"location":"api/eigenvalues/","page":"Eigenvalues","title":"Eigenvalues","text":"Pages = [\"eigenvalues.md\"]","category":"page"},{"location":"api/eigenvalues/#Interval-matrices-eigenvalues","page":"Eigenvalues","title":"Interval matrices eigenvalues","text":"","category":"section"},{"location":"api/eigenvalues/","page":"Eigenvalues","title":"Eigenvalues","text":"Modules=[IntervalLinearAlgebra]\nPages=[\"interval_eigenvalues.jl\"]\nPrivate=false","category":"page"},{"location":"api/eigenvalues/#IntervalLinearAlgebra.eigenbox-Union{Tuple{Symmetric{Interval{T}, Array{Interval{T}, 2}}}, Tuple{T}} where T","page":"Eigenvalues","title":"IntervalLinearAlgebra.eigenbox","text":"eigenbox(A)\n\nReturns an enclosure of all the eigenvalues of A. If A is symmetric, than the output is a real interval, otherwise it is a complex interval.\n\nAlgorithm\n\nThe algorithms used by the function are described in [HLA13].\n\nNotes\n\nThe enclosure is not rigorous, meaning that the real eigenvalue problems solved internally utilize normal floating point computations.\n\nExamples\n\njulia> A = [0 -1 -1;2 -1.399.. -0.001 0;1 0.5 -1]\n3×3 Matrix{Interval{Float64}}:\n [0, 0]  [-1, -1]                       [-1, -1]\n [2, 2]       [-1.39901, -0.000999999]    [0, 0]\n [1, 1]        [0.5, 0.5]               [-1, -1]\n\njulia> eigenbox(A)\n[-1.90679, 0.970154] + [-2.51903, 2.51903]im\n\n\n\n\n\n","category":"method"},{"location":"api/eigenvalues/#Floating-point-eigenvalues-verification","page":"Eigenvalues","title":"Floating point eigenvalues verification","text":"","category":"section"},{"location":"api/eigenvalues/","page":"Eigenvalues","title":"Eigenvalues","text":"Modules=[IntervalLinearAlgebra]\nPages=[\"verify_eigs.jl\"]\nPrivate=false","category":"page"},{"location":"api/eigenvalues/#IntervalLinearAlgebra.bound_perron_frobenius_eigenvalue-Union{Tuple{AbstractMatrix{T}}, Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T<:Real","page":"Eigenvalues","title":"IntervalLinearAlgebra.bound_perron_frobenius_eigenvalue","text":"bound_perron_frobenius_eigenvalue(A, max_iter=10)\n\nFinds an upper bound for the Perron-Frobenius eigenvalue of the non-negative matrix A.\n\nInput\n\nA – square real non-negative matrix\nmax_iter – maximum number of iterations of the power method used internally to compute   an initial approximation of the Perron-Frobenius eigenvector\n\nExample\n\njulia> A = [1 2;3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> bound_perron_frobenius_eigenvalue(A)\n5.372281323275249\n\n\n\n\n\n","category":"method"},{"location":"api/eigenvalues/#IntervalLinearAlgebra.verify_eigen-Tuple{Any}","page":"Eigenvalues","title":"IntervalLinearAlgebra.verify_eigen","text":"verify_eigen(A[, λ, X0]; w=0.1, ϵ=1e-16, maxiter=10)\n\nFinds a rigorous bound for the eigenvalues and eigenvectors of A. Eigenvalues are treated as simple.\n\nInput\n\nA       – matrix\nλ       – (optional) approximate value for an eigenvalue of A\nX0      – (optional) eigenvector associated to λ\nw       – relative inflation parameter\nϵ       – absolute inflation parameter\nmaxiter – maximum number of iterations\n\nOutput\n\nInterval bounds on eigenvalues and eigenvectors.\nA boolean certificate (or a vector of booleans if all eigenvalues are computed) cert. If cert[i]==true, then the bounds for the ith eigenvalue and eigenvectore are rigorous, otherwise not.\n\nAlgorithm\n\nThe algorithm for this function is described in [RUM01].\n\nExample\n\njulia> A = Symmetric([1 2;2 3])\n2×2 Symmetric{Int64, Matrix{Int64}}:\n 1  2\n 2  3\n\njulia> evals, evecs, cert = verify_eigen(A);\n\njulia> evals\n2-element Vector{Interval{Float64}}:\n [-0.236068, -0.236067]\n  [4.23606, 4.23607]\n\njulia> evecs\n2×2 Matrix{Interval{Float64}}:\n [-0.850651, -0.85065]  [0.525731, 0.525732]\n  [0.525731, 0.525732]  [0.85065, 0.850651]\n\njulia> cert\n2-element Vector{Bool}:\n 1\n 1\n\n\n\n\n\n","category":"method"},{"location":"api/precondition/#Preconditioners","page":"Preconditioners","title":"Preconditioners","text":"","category":"section"},{"location":"api/precondition/","page":"Preconditioners","title":"Preconditioners","text":"Pages = [\"precondition.md\"]","category":"page"},{"location":"api/precondition/","page":"Preconditioners","title":"Preconditioners","text":"Modules=[IntervalLinearAlgebra]\nPages=[\"precondition.jl\"]\nPrivate=false","category":"page"},{"location":"api/precondition/#IntervalLinearAlgebra.InverseDiagonalMidpoint","page":"Preconditioners","title":"IntervalLinearAlgebra.InverseDiagonalMidpoint","text":"InverseDiagonalMidpoint <: AbstractPrecondition\n\nPreconditioner that preconditions the linear system Ax=b with the diagonal matrix of A_c^-1, where A_c is the midpoint matrix of A.\n\nNotes\n\nAn object of type InverseDiagonalMidpoint is a function with method\n  (idmp::InverseDiagonalMidpoint)(A::AbstractMatrix{T},\n                                  b::AbstractVector{T}) where {T<:Interval}\n\nExample\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> b = [-2..2, -2..2]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-2, 2]\n\njulia> idmp = InverseDiagonalMidpoint()\nInverseDiagonalMidpoint()\n\njulia> idmp(A, b)\n(Interval{Float64}[[0.666666, 1.33334] [-0.666667, 0.333334]; [-0.333334, 0.666667] [0.666666, 1.33334]], Interval{Float64}[[-0.666667, 0.666667], [-0.666667, 0.666667]])\n\n\n\n\n\n","category":"type"},{"location":"api/precondition/#IntervalLinearAlgebra.InverseMidpoint","page":"Preconditioners","title":"IntervalLinearAlgebra.InverseMidpoint","text":"InverseMidpoint <: AbstractPrecondition\n\nPreconditioner that preconditions the linear system Ax=b with A_c^-1, where A_c is the midpoint matrix of A.\n\nNotes\n\nAn object of type InverseMidpoint is a function with method\n  (imp::InverseMidpoint)(A::AbstractMatrix{T},\n                         b::AbstractVector{T}) where {T<:Interval}\n\nExamples\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> b = [-2..2, -2..2]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-2, 2]\n\njulia> imp = InverseMidpoint()\nInverseMidpoint()\n\njulia> imp(A, b)\n(Interval{Float64}[[0.594594, 1.40541] [-0.540541, 0.540541]; [-0.540541, 0.540541] [0.594594, 1.40541]], Interval{Float64}[[-0.756757, 0.756757], [-0.756757, 0.756757]])\n\n\n\n\n\n","category":"type"},{"location":"api/precondition/#IntervalLinearAlgebra.NoPrecondition","page":"Preconditioners","title":"IntervalLinearAlgebra.NoPrecondition","text":"NoPrecondition <: AbstractPrecondition\n\nType of the trivial preconditioner which does nothing.\n\nNotes\n\nAn object of type NoPrecondition is a function with method\n  (np::NoPrecondition)(A::AbstractMatrix{T},\n                       b::AbstractVector{T}) where {T<:Interval}\n\nExample\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> b = [-2..2, -2..2]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-2, 2]\n\njulia> np = NoPrecondition()\nNoPrecondition()\n\njulia> np(A, b)\n(Interval{Float64}[[2, 4] [-2, 1]; [-1, 2] [2, 4]], Interval{Float64}[[-2, 2], [-2, 2]])\n\n\n\n\n\n","category":"type"},{"location":"explanations/preconditioning/#Preconditioning-interval-linear-systems","page":"Preconditioning","title":"Preconditioning interval linear systems","text":"","category":"section"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"Pages = [\"preconditioning.md\"]","category":"page"},{"location":"explanations/preconditioning/#Basic-concepts","page":"Preconditioning","title":"Basic concepts","text":"","category":"section"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"Consider the square interval linear system","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"mathbfAx=mathbfb","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"preconditioning the interval linear system by a real matrix C means to multiply both sides of the equation by C, obtaining the new system","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"CmathbfAx=Cmathbfb","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"which is called preconditioned system. Let us denote by A_c the midpoint matrix of mathbfA. Popular choices for C are","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"Inverse midpoint preconditioning: Capprox A_c^-1\nInverse diagonal midpoint preconditioning: Capprox D_A_c^-1 where D_A_c is the diagonal matrix containing the main diagonal of A_c.","category":"page"},{"location":"explanations/preconditioning/#Advantages-of-preconditioning","page":"Preconditioning","title":"Advantages of preconditioning","text":"","category":"section"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"Using preconditioning to solve an interval linear system can have mainly two advantages.","category":"page"},{"location":"explanations/preconditioning/#Extend-usability-of-algorithms","page":"Preconditioning","title":"Extend usability of algorithms","text":"","category":"section"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"Some algorithms require the matrix to have a specific structure in order to be used. For example Hansen-Bliek-Rohn algorithm requires mathbfA to be an H-matrix. However, the algorithm can be extended to work to strongly regular matrices using inverse midpoint preconditioning. (Recall that an interval matrix is strongly regular if A_c^-1mathbfA is an H-matrix).","category":"page"},{"location":"explanations/preconditioning/#Improve-numerical-stability","page":"Preconditioning","title":"Improve numerical stability","text":"","category":"section"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"Even if the algorithms theoretically work, they can be prone to numerical instability without preconditioning. This is demonstrated with the following example, a more deep theoretical analysis can be found in [NEU90].","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"Let mathbfA be an interval lower triangular matrix with all 1 1 in the lower part, for example","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"using IntervalLinearAlgebra\n\nN = 5 # problem dimension\nA = tril(fill(1..1, N, N))","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"and let mathbfb having -2 2 as first element and all other elements set to zero","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"b = vcat(-2..2, fill(0, N-1))","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"the \"pen and paper\" solution would be  -2 2 -2 2 0 0 0 0 0 0^mathsfT, that is a vector with -2 2 as first two elements and all other elements set to zero. Now, let us try to solve without preconditioning.","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"solve(A, b, GaussianElimination(), NoPrecondition())","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"solve(A, b, HansenBliekRohn(), NoPrecondition())","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"It can be seen that the width of the intervals grows exponentially, this gets worse with bigger matrices.","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"N = 100 # problem dimension\nA1 = tril(fill(1..1, N, N))\nb1 = [-2..2, fill(0..0, N-1)...]\n\nsolve(A1, b1, GaussianElimination(), NoPrecondition())","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"solve(A1, b1, HansenBliekRohn(), NoPrecondition())","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"However this numerical stability issue is solved using inverse midpoint preconditioning.","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"solve(A, b, GaussianElimination(), InverseMidpoint())","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"solve(A, b, HansenBliekRohn(), InverseMidpoint())","category":"page"},{"location":"explanations/preconditioning/#Disadvantages-of-preconditioning","page":"Preconditioning","title":"Disadvantages of preconditioning","text":"","category":"section"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"While preconditioning is useful, sometimes even necessary, to solve interval linear systems, it comes at a price. It is important to understand that the preconditioned interval linear system is not equivalent to the original one, particularly the preconditioned problem can have a larger solution set.","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"Let us consider the following linear system","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"A = [2..4 -2..1;-1..2 2..4]","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"b = [-2..2, -2..2]","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"Now we plot the solution set of the original and preconditioned problem using Oettli-Präger","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"using LazySets, Plots\n\npolytopes = solve(A, b, LinearOettliPrager())\npolytopes_precondition = solve(A, b, LinearOettliPrager(), InverseMidpoint())\n\nplot(UnionSetArray(polytopes_precondition), ratio=1, label=\"preconditioned\", legend=:right)\nplot!(UnionSetArray(polytopes), label=\"original\", α=1)\nxlabel!(\"x\")\nylabel!(\"y\")\nsavefig(\"solution_set_precondition.png\") # hide","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"(Image: )","category":"page"},{"location":"explanations/preconditioning/#Take-home-lessons","page":"Preconditioning","title":"Take-home lessons","text":"","category":"section"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"Preconditioning an interval linear system can enlarge the solution set\nPreconditioning is sometimes needed to achieve numerical stability\nA rough rule of thumb (same used by IntervalLinearAlgebra.jl if no preconditioning is specified)\nnot needed for M-matrices and strictly diagonal dominant matrices\nmight be needed for H-matrices (IntervalLinearAlgebra.jl uses inverse midpoint by default with H-matrices)\nmust be used for strongly regular matrices","category":"page"},{"location":"wip/","page":"Applications","title":"Applications","text":"still work in progress, stay tuned!","category":"page"},{"location":"CONTRIBUTING/#IntervalLinearAlgebra.jl-contribution-guidelines","page":"Contributing","title":"IntervalLinearAlgebra.jl contribution guidelines","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"First of all, huge thanks for your interest in the package! ✨","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"This page has some hopefully useful guidelines. If this is your first time contributing, please read the pull request-workflow section, mainly to make sure everything works smoothly and you don't get stuck with some nasty technicalities. ","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"You are also encouraged to read the coding and documentation guidelines, but you don't need to deeply study and memorize those. Core developers are here to help you. Most importantly, relax and have fun!","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"The core developers of the package can be found in the #intervals channel in the Julia slack or zulip, links to join the platforms can be found here","category":"page"},{"location":"CONTRIBUTING/#Opening-issues","page":"Contributing","title":"Opening issues","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"If you spot something strange in the software (something doesn't work or doesn't behave as expected) do not hesitate to open a bug issue.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"If have an idea of how to make the package better (a new feature, a new piece of documentation, an idea to improve some existing feature), you can open an enhancement issue. ","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"In both cases, try to follow the template, but do not worry if you don't know how to fill something. ","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"If you feel like your issue does not fit any of the above mentioned templates (e.g. you just want to ask something), you can also open a blank issue.","category":"page"},{"location":"CONTRIBUTING/#Pull-request-workflow","page":"Contributing","title":"Pull request workflow","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Pull requests are also warmly welcome. For small fixes/additions, feel free to directly open a PR. For bigger more ambitious PRs, it is preferable to open an issue first to discuss it. As a rule of thumb, every pull request should be as atomic as possible (fix one bug, add one feature, address one issue).","category":"page"},{"location":"CONTRIBUTING/#Setup","page":"Contributing","title":"Setup","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"note: Note\nThis is just one way, you can do differently (e.g. clone your fork and add the original repo as upstream). In that case, make sure to use the correct remote names","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"This is something that needs to be done only once, the first time you start contributing","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"1. From the Julia REPL in package mode (you can enter package mode by typing ]) do","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"pkg> dev IntervalLinearAlgebra","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"this will clone the repository into .julia/dev/IntervalLinearAlgebra. When you dev the package, Julia will use the code in the dev folder instead of the official released one. If you want to go back to use the released version, you can do free IntervalLinearAlgebra.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"2. Fork the repository.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"3. Navigate to .julia/dev/IntervalLinearAlgebra where you cloned the original repository before. Now you need to add your fork as remote. This can be done with","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"git remote add $your_remote_name $your_fork_url","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"your_remote_name can be whatever you want. your_fork_url is the url you would use to clone your fork repository. For example if your github username is lucaferranti and you want to call the remote lucaferranti then the previous command would be","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"git remote add lucaferranti https://github.com/lucaferranti/IntervalLinearAlgebra.jl.git","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"you can verify that you have the correct remotes with git remote -v the output should be similar to","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"lucaferranti  https://github.com/lucaferranti/IntervalLinearAlgebra.jl.git (fetch)\nlucaferranti  https://github.com/lucaferranti/IntervalLinearAlgebra.jl.git (push)\norigin        https://github.com/JuliaIntervals/IntervalLinearAlgebra.jl.git (fetch)\norigin        https://github.com/JuliaIntervals/IntervalLinearAlgebra.jl.git (push)","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Now everything is set!","category":"page"},{"location":"CONTRIBUTING/#Contribution-workflow","page":"Contributing","title":"Contribution workflow","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"0. Navigate to .julia/dev/IntervalLinearAlgebra and make sure you are on the main branch. You can check with git branch and if needed use git switch main to switch to the main branch. The next steps assume you are in the IntervalLinearAlgebra folder.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"1. Before you start modifying, it's good to make sure that your local main branch is synchronized with the main branch in the package repo. To do so, run","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"git fetch origin\ngit merge origin/main","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Since you should never directly modify the main branch locally, this should not cause any conflicts. If you didn't follow the previous setup instructions, you may need to change origin with the appropriate remote name.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"2. Now create a new branch for the new feature you want to develop. If possible, the branch should start with your name/initials and have a short but descriptive name of what you are doing (no strict rules). For example, if I (Luca Ferranti) want to fix the code that computes the eigenvalues of a symmetric matrix, I would call the branch lf-symmetric-eigvals or something like that. You can create a new branch and switch to it with","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"git switch -c lf-symmetric-eigvals","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"If you are targetting a specific issue, you can also name the branch after the issue number, e.g. lf-42.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"3. Now let the fun begin! Fix bugs, add the new features, modify the docs, whatever you do, it's gonna be awesome! Check also the coding guidelines and documentation guidelines. Do not worry if it feels like a lot of rules, the core developers are here to help and guide.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"4. It is important to run the tests of the package locally, to check that you haven't accidentally broken anything. You can run the tests with","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"julia --project test/runtests.jl","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"If you have changed the documentation, you can build it locally with","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"julia --project=docs docs/make.jl","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"This will build the docs in the docs/build folder, you can open docs/build/index.html and check that everything looks nice. Check also in the terminal that you don't have error messages (no broken links, doctests pass).","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"5. When you are ready, commit your changes. If example you want to commit src/file1.jl, src/file2.jl","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"git add src/file1.jl src/file2.jl\ngit commit -m \"short description of what you did\"","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"You can also add and commit all changes at once with","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"git commit -a -m \"short description of what you did\"","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"finally you are ready to push to your fork. If your fork remote is called lucaferranti and your branch is called lf-symmetric-eigvals, do","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"git push -u lucaferranti lf-symmetric-eigvals","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"The -u flag sets the upstream, so next time you want to push to the same branch you can just do git push.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"6. Next, go to the package repository, you should see a message inviting you to open a pull request, do it! Make sure you are opening the PR to origin/main. Try to fill the blanks in the pull request template, but do not worry if you don't know anything. Also, your work needs not be polished and perfect to open the pull request! You are also very welcome to open it as a draft and request feedback, assistance, etc.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"7. If nothing happens within 7 working days feel free to ping Luca Ferranti (@lucaferranti) every 1-2 days until you get his attention.","category":"page"},{"location":"CONTRIBUTING/#Coding-guideline","page":"Contributing","title":"Coding guideline","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Try to roughly follow the bluestyle style guideline.\nIf you add new functionalities, they should also be tested. Exported functions should also have a docstring.\nThe test folder should roughly follow the structure of the src folder. That is if you create src/file1.jl there should also be test/test_file1.jl. There can be exceptions, the main point being that both test and src should have a logical structure and should be easy to find the tests for a given function.\nThe runtests.jl should have only inlcude statements.","category":"page"},{"location":"CONTRIBUTING/#Package-version","page":"Contributing","title":"Package version","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Generally, if the pull request changes the source code, a new version of the package should be released. This means, that if you change the source code, you should also update the version entry in the Project.toml. Since the package is below version 1, the version update rules are","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"update minor version for breaking changes, e.g. 0.3.5  => 0.4.0\nupdate patch version for non breaking changes, e.g. 0.3.5 => 0.3.6\nIt is perfectly fine that you are not sure how to update the version. Just mention in the PR and you will receive guidance\nThe person who merges the PR also register the new version.","category":"page"},{"location":"CONTRIBUTING/#Add-dependency","page":"Contributing","title":"Add dependency","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"If the function you are adding needs an external package (say Example.jl), this should be added as dependency, to do so","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Go to IntervalLinearAlgebra.jl and start a Julia session and activate the current environment with julia --project\nEnter the package mode (press ]) and add the package you want to add, e.g ]add Example.\nYou can verify that the package was added by typing st while in package mode. You can exit the package mode by pressing backspace\nOpen the Project.toml file, your package should now be listed in the [deps] section.\nIn the [compat] section, specify the compatibility requirements. Packages are listed alphabetically. More details about specifying compatibility can be found here\nIn the IntervalLinearAlgebra.jl file, add the line using Example together with the other using statements, or import Example: fun1, fun2 if you are planning to extend those functions.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"If the dependency is quite heavy and used only by some functionalities, you may consider adding that as optional dependency. To do so,","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Repeat the steps 1-5 above\nIn the [deps] section of Project.toml locate the package you want to make an optional dependency and move the corresponding line to [extras], keep alphabetical ordering.\nAdd the dependency name to the test entry in the [targets] section\nIn the IntervalLinearAlgebra.jl file, locate the __init__ function and add the line","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"@require \"\"\"Example = \"7876af07-990d-54b4-ab0e-23690620f79a\" include(\"file.jl\")\"\"\"","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"where file.jl is the file containing the functions needing Example.jl. The line Example = \"7876af07-990d-54b4-ab0e-23690620f79a\" is the same in the Project.toml","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"In file.jl the first line should be using .Example (or import .Example: fun1, fun2), note the dot before the package name. Then write the functions in the file normally","category":"page"},{"location":"CONTRIBUTING/#Documentation-guideline","page":"Contributing","title":"Documentation guideline","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Documentation is written with Documenter.jl. Documentation files are in docs/src, generally as markdown file.\nIf you want to include a Julia code example that is not executed in the markdown file, use ```julia blocks, e.g.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"```julia\na = 1\nb = 2\n```","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Julia code that is executed should use ```@example blocks, e.g.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"```@example\na = 1\nb = 2\n```","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"If you want to reuse variables between @example blocks, they should be named, for example","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"```@example filename\na = 1\nb = 2\n```\n\n... some text ...\n\n```@example filename\nc = a + b\n```","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"If you want to run a Julia code block but don't want the output to be displayed, add nothing # hide as last line of the code block.\nYou can plot and include figures as follows","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"```@example\n# code for plotting\nsavefig(\"figname.png\") # hide\n```\n\n![][figname.png]","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Use single ticks for inline code `A` and double ticks for maths ``A``. For single line equations, use \nFor single-line equations, use ```math blocks, e.g.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"```math\n|A_cx-b_c| \\le A_\\Delta|x| + b_\\Delta,\n```","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"You can refer to functions in the pacakge with [`func_name`](@ref)\nYou can quote references with [[REF01]](@ref)\nIf you want to add references, you can use the following template","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"#### [REF01] \n\n```@raw html\n<ul><li>\n```\nAuthor(s), [*Paper name in italic*](link_to_pdf_if_available), other infos (publisher, year, etc.)\n```@raw html\n<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>\n```\n```\nINSERT BIBTEX HERE\n```\n```@raw html\n</details></li></ul>\n```\n---","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"If the pdf of the paper is freely (and legally!) available online, make the title of the paper a link to it.\nThe reference code should be first 3 letters of first author surname + last two digits of year, e.g [FER87]. To disambiguate duplicates, use letter, e.g. [FER87a], [FER87b].","category":"page"},{"location":"CONTRIBUTING/#Docstrings","page":"Contributing","title":"Docstrings","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Each exported function should have a docstring. The docstring should roughly follow the following structure","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"\"\"\"\n    funname(param1, param2[, optional_param])\n\nA short description (1-2 lines) of what the function does\n\n### Input\n\nLis of inputs. Not needed if clear from description and signature.\n\n### Output\n\nList of outputs. Not needed if clear from description and signature.\n\n### Notes\n\nAnything else which is important.\n\n### Algorithm\n\nWhat algorithms the function uses, preferably with references.\n\n### Example\n\nAt least one example, formatted as julia REPL, of what the function does.\nPreferably, as a doctest.\n\"\"\"","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Optional parameters in the function signature go around brackets.\nList of inputs and outputs can be omitted if the function has few parameters and they are already clearly explained by the function signature and description.\nExamples should be doctests. Exceptions to this can occur if e.g. the function is not deterministic (random initialization) or requires a heavy optional dependency.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Here is an example","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"\"\"\"\n    something(A::Matrix{T}, b::Vector{T}[, tol=1e-10]) where {T<:Interval}\n\nthis function computes the somethig product between the interval matrix ``A`` and \ninterval vector ``b``.\n\n### Input\n\n`A`   -- interval matrix\n`b`   -- interval vector\n`tol` -- (optional), tolerance to compute the something product, default 1e-10\n\n### Output\n\nThe interval vector representing the something product.\n\n### Notes\n\nIf `A` and `b` are real, use the [`somethingelse`](@ref) function instead.\n\n### Algorithm\n\nThe function uses the *something sometimes somewhere* algorithm proposed by Someone in [[SOM42]](@ref).\n\n### Example\n\n```jldoctest\njulia> A = [1..2 3..4;5..6 7..8]\n2×2 Matrix{Interval{Float64}}:\n[1, 2]  [3, 4]\n[5, 6]  [7, 8]\n\njulia> b = [-2..2, -2..2]\n2-element Vector{Interval{Float64}}:\n[-2, 2]\n[-2, 2]\n\njulia> something(A, b)\n2-element Vector{Interval{Float64}}:\n[-1, 1]\n[-7, 8]\n```\n\"\"\"","category":"page"},{"location":"CONTRIBUTING/#Acknowledgments","page":"Contributing","title":"Acknowledgments","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Here is a list of useful resources from which this guideline was inspired","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"JuliaReach developers docs\nMaking a first Julia pull request\nColPrac\nJulia contributing guideline","category":"page"},{"location":"tutorials/linear_systems/#Linear-systems","page":"Linear systems","title":"Linear systems","text":"","category":"section"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"Pages = [\"linear_systems.md\"]","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"This tutorial will show you how to solve linear systems rigorously using IntervalLinearAlgebra.jl.","category":"page"},{"location":"tutorials/linear_systems/#Solve-interval-linear-systems","page":"Linear systems","title":"Solve interval linear systems","text":"","category":"section"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"An interval linear system mathbfAx=mathbfb is a linear system where mathbfA and mathbfb contain intervals. In general, the solution set mathbfx can have a complex non-convex shape and can thus be hard to characterize exactly (see this article for more details). Hence we are interested in finding an interval box containing mathbfx. In IntervalLinearAlgebra.jl, this is achieved through the solve function, which gives a handy interface to choose the algorithm and preconditioning mechanism. The syntax to call solve is ","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"solve(A, b, method, precondition)","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"A is an interval matrix\nb is an interval vector\nmethod is an optional parameter to choose the algorithm used to solve the interval linear system, see below for more details\nprecondition is an optional parameter to choose the preconditioning for the problem. More details about preconditoining can be found here","category":"page"},{"location":"tutorials/linear_systems/#Methods","page":"Linear systems","title":"Methods","text":"","category":"section"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"The supported methods are","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"Direct solvers\nGaussianElimination\nHansenBliekRohn\nLinearOettliPrager (requires importing LazySets.jl)\nIterative solvers\nLinearKrawczyk\nJacobi\nGaussSeidel\nNonLinearOettliPrager (requires importing IntervalConstraintProgramming.jl)","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"LinearOettliPrager and NonLinearOettliPrager are \"special\" in the sense that they try to exactly characterize the solution set using Oettli-Präger and are not considered in this tutorial. More information about them can be found here. The other solvers return a vector of intervals, representing an interval enclosure of the solution set. If the method is not specified, Gaussian elimination is used by default.","category":"page"},{"location":"tutorials/linear_systems/#Preconditioning","page":"Linear systems","title":"Preconditioning","text":"","category":"section"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"The supported preconditioning mechanisms are","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"NoPrecondition\nInverseMidpoint\nInverseDiagonalMidpoint","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"If preconditioning is not specified, then an heuristic strategy based on the type of matrix and solver is used to choose the preconditioning. The strategy is discussed at the end of the preconditioning tutorial.","category":"page"},{"location":"tutorials/linear_systems/#Examples","page":"Linear systems","title":"Examples","text":"","category":"section"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"We now demonstrate a few examples using the solve function, these examples are taken from [HOR19].","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"using IntervalLinearAlgebra\n\nA = [4..6 -1..1 -1..1 -1..1;-1..1 -6.. -4 -1..1 -1..1;-1..1 -1..1 9..11 -1..1;-1..1 -1..1 -1..1 -11.. -9]","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"b = [-2..4, 1..8, -4..10, 2..12]","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"solve(A, b, HansenBliekRohn())","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"solve(A, b, GaussianElimination())","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"solve(A, b, GaussSeidel())","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"For iterative methods, an additional optional parameter X0 representing an initial guess for the solution's enclosure can be given. If not given, a rough initial enclosure is computed using the enclose function.","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"X0 = fill(-5..5, 4)\nsolve(A, b, GaussSeidel(), InverseMidpoint(), X0)","category":"page"},{"location":"tutorials/linear_systems/#Verify-real-linear-systems","page":"Linear systems","title":"Verify real linear systems","text":"","category":"section"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"IntervalLinearAlgebra.jl also offers functionalities to solve real linear systems rigorously. It is of course possible to just convert the real system to an interval system and use the methods described above. In this situation, however, the system will have the property where the diameters of the intervals will be very small (zero or a few floating point units). To solve these kind of systems, it can be more efficient to use the epsilon inflation method [RUM10], especially for bigger matrices. Here is an example","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"A = [1.0 2;3 4]","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"b = [3, 7]","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"the real linear system Ax=b can now be solved rigorously using the epsilon_inflation function.","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"x, cert = epsilon_inflation(A, b)\n@show cert\nx","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"This function returns two values: an interval vector x and a boolean certificate cert. If cert==true then x is guaranteed to be an enclosure of the real linear system Ax=b. If cert == false then the algorithm could not verify that the enclosure is rigorous, i.e. it may or may not contain the true solution.","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"In the following example the epsilon inflation method returns a non-rigorous bound","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"A1 = [1..1+1e-16 2;3 4]\nx1, cert = epsilon_inflation(A1, b)\n@show cert\nx1","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"Since the matrix A1 is non-regular (it contains the matrix beginbmatrix1234endbmatrix which is singluar), the solution set is unbounded, hence the algorithm could not prove (rightly) that x1 is an enclosure of the true solution. ","category":"page"},{"location":"api/misc/#Miscellaneous","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"api/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"Other possibly useful functionalities.","category":"page"},{"location":"api/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"Pages = [\"misc.md\"]","category":"page"},{"location":"api/misc/#Matrix-multiplication-API","page":"Miscellaneous","title":"Matrix multiplication API","text":"","category":"section"},{"location":"api/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"set_multiplication_mode","category":"page"},{"location":"api/misc/#IntervalLinearAlgebra.set_multiplication_mode","page":"Miscellaneous","title":"IntervalLinearAlgebra.set_multiplication_mode","text":"set_multiplication_mode(multype)\n\nSets the algorithm used to perform matrix multiplication with interval matrices.\n\nInput\n\nmultype – symbol describing the algorithm used\n:slow – uses traditional matrix multiplication algorithm.\n:rank1 – uses rank1 update\n:fast – computes an enclosure of the matrix product using the midpoint-radius            notation of the matrix [RUM10].\n\nNotes\n\nBy default, :fast is used.\nUsing fast is generally significantly faster, but it may return larger intervals, especially if midpoint and radius have the same order of magnitude   (50% overestimate at most) [RUM99].\n\n\n\n\n\n","category":"function"},{"location":"api/misc/#Others","page":"Miscellaneous","title":"Others","text":"","category":"section"},{"location":"api/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"Modules = [IntervalLinearAlgebra]\nPages = [\"utils.jl\", \"rref.jl\"]","category":"page"},{"location":"api/misc/#IntervalLinearAlgebra.Orthants","page":"Miscellaneous","title":"IntervalLinearAlgebra.Orthants","text":"Orthants\n\nIterator to go through all the 2ⁿ vectors of length n with elements 1. This is equivalento to going through the orthants of an n-dimensional euclidean space.\n\nFields\n\nn::Int – dimension of the vector space\n\nExample\n\njulia> for or in Orthants(2)\n       @show or\n       end\nor = [1, 1]\nor = [-1, 1]\nor = [1, -1]\nor = [-1, -1]\n\n\n\n\n\n","category":"type"},{"location":"api/misc/#IntervalLinearAlgebra.comparison_matrix-Union{Tuple{StaticArrays.SMatrix{N, N, T, M}}, Tuple{T}, Tuple{M}, Tuple{N}} where {N, M, T<:Interval}","page":"Miscellaneous","title":"IntervalLinearAlgebra.comparison_matrix","text":"comparison_matrix(A::AbstractMatrix{T}) where {T<:Interval}\n\nComputes the comparison matrix A of the given interval matrix A according to the definition Aᵢᵢ = mig(Aᵢᵢ) and Aᵢⱼ = -mag(Aᵢⱼ) if ij.\n\nExamples\n\njulia> A = [2..4 -1..1; -1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> comparison_matrix(A)\n2×2 Matrix{Float64}:\n  2.0  -1.0\n -1.0   2.0\n\n\n\n\n\n","category":"method"},{"location":"api/misc/#IntervalLinearAlgebra.enclose-Union{Tuple{T}, Tuple{N}, Tuple{StaticArrays.StaticMatrix{N, N, T}, StaticArrays.StaticVector{N, T}}} where {N, T<:Interval}","page":"Miscellaneous","title":"IntervalLinearAlgebra.enclose","text":"enclose(A::AbstractMatrix{T}, b::AbstractVector{T}) where {T<:Interval}\n\nComputes an enclosure of the solution of the interval linear system Ax=b using the algorithm described in sec. 5.7.1 of [HOR19].\n\n\n\n\n\n","category":"method"},{"location":"api/misc/#IntervalLinearAlgebra.interval_isapprox-Tuple{Interval, Interval}","page":"Miscellaneous","title":"IntervalLinearAlgebra.interval_isapprox","text":"interval_isapprox(a::Interval, b::Interval; kwargs)\n\nChecks whether the intervals a and b are approximate equal, that is both their lower and upper bound are approximately equal.\n\nKeywords\n\nSame of Base.isapprox\n\nExample\n\njulia> a = 1..2\n[1, 2]\n\njulia> b = a + 1e-10\n[1, 2.00001]\n\njulia> interval_isapprox(a, b)\ntrue\n\njulia> interval_isapprox(a, b; atol=1e-15)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/misc/#IntervalLinearAlgebra.interval_norm-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"Miscellaneous","title":"IntervalLinearAlgebra.interval_norm","text":"interval_norm(A::AbstractMatrix{T}) where {T<:Interval}\n\ncomputes the infinity norm of interval matrix A.\n\nExamples\n\njulia> A = [2..4 -1..1; -1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> interval_norm(A)\n5.0\n\n\n\n\n\n","category":"method"},{"location":"api/misc/#IntervalLinearAlgebra.interval_norm-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Interval","page":"Miscellaneous","title":"IntervalLinearAlgebra.interval_norm","text":"interval_norm(A::AbstractVector{T}) where {T<:Interval}\n\ncomputes the infinity norm of interval vector v.\n\nExamples\n\njulia> b = [-2..2, -3..2]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-3, 2]\n\njulia> interval_norm(b)\n3.0\n\n\n\n\n\n","category":"method"},{"location":"api/misc/#IntervalLinearAlgebra.rref!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"Miscellaneous","title":"IntervalLinearAlgebra.rref!","text":"rref!(A::AbstractMatrix{T}) where {T<:Interval}\n\nIn-place version of rref.\n\n\n\n\n\n","category":"method"},{"location":"api/misc/#IntervalLinearAlgebra.rref-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"Miscellaneous","title":"IntervalLinearAlgebra.rref","text":"rref(A::AbstractMatrix{T}) where {T<:Interval}\n\nComputes the reduced row echelon form of the interval matrix A using maximum mignitude as pivoting strategy.\n\nExamples\n\njulia> A = [2..4 -1..1; -1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> rref(A)\n2×2 Matrix{Interval{Float64}}:\n [2, 4]  [-1, 1]\n [0, 0]       [1.5, 4.5]\n\n\n\n\n\n","category":"method"},{"location":"api/classify/#Interval-matrices-classification","page":"Interval matrices classification","title":"Interval matrices classification","text":"","category":"section"},{"location":"api/classify/","page":"Interval matrices classification","title":"Interval matrices classification","text":"Pages = [\"classify.md\"]","category":"page"},{"location":"api/classify/","page":"Interval matrices classification","title":"Interval matrices classification","text":"Modules=[IntervalLinearAlgebra]\nPages = [\"classify.jl\"]","category":"page"},{"location":"api/classify/#IntervalLinearAlgebra.is_H_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"Interval matrices classification","title":"IntervalLinearAlgebra.is_H_matrix","text":"is_H_matrix(A::AbstractMatrix{T}) where {T<:Interval}\n\nTests whether the square interval matrix A is an H-matrix, by testing that A^-1e0, where e=1 1  1ᵀ. Note that in practice it tests that a floating point approximation of A^-1e satisfies the condition. For more details see section 4.4 of [HOR19].\n\nExamples\n\njulia> A = [2..4 -1..1; -1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> is_H_matrix(A)\ntrue\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> is_H_matrix(A)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/classify/#IntervalLinearAlgebra.is_M_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"Interval matrices classification","title":"IntervalLinearAlgebra.is_M_matrix","text":"is_M_matrix(A::AbstractMatrix{T}) where {T<:Interval}\n\nChecks whether the square interval matrix A is an M-matrix, that is a Z-matrix with non-negative inverse. For more details see section 4.2 of [HOR19].\n\nExamples\n\njulia> A = [2..2 -1..0; -1..0 2..2]\n2×2 Matrix{Interval{Float64}}:\n  [2, 2]  [-1, 0]\n [-1, 0]   [2, 2]\n\njulia> is_M_matrix(A)\ntrue\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> is_M_matrix(A)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/classify/#IntervalLinearAlgebra.is_Z_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"Interval matrices classification","title":"IntervalLinearAlgebra.is_Z_matrix","text":"is_Z_matrix(A::AbstractMatrix{T}) where {T<:Interval}\n\nChecks whether the square interval matrix A is a Z-matrix, that is whether Aᵢⱼ0 for all ij. For more details see section 4.2 of [HOR19].\n\nExamples\n\njulia> A = [2..4 -2.. -1; -2.. -1 2..4]\n2×2 Matrix{Interval{Float64}}:\n   [2, 4]  [-2, -1]\n [-2, -1]    [2, 4]\n\njulia> is_Z_matrix(A)\ntrue\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> is_Z_matrix(A)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/classify/#IntervalLinearAlgebra.is_strictly_diagonally_dominant-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"Interval matrices classification","title":"IntervalLinearAlgebra.is_strictly_diagonally_dominant","text":"is_strictly_diagonally_dominant(A::AbstractMatrix{T}) where {T<:Interval}\n\nChecks whether the square interval matrix A of order n is stictly diagonally dominant, that is if mig(Aᵢᵢ)  _k  i mag(Aᵢₖ) for i=1n. For more details see section 4.5 of [HOR19].\n\nExamples\n\njulia> A = [2..4 -1..1; -1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> is_strictly_diagonally_dominant(A)\ntrue\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> is_strictly_diagonally_dominant(A)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/classify/#IntervalLinearAlgebra.is_strongly_regular-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"Interval matrices classification","title":"IntervalLinearAlgebra.is_strongly_regular","text":"is_strongly_regular(A::AbstractMatrix{T}) where {T<:Interval}\n\nTests whether the square interval matrix A is strongly regular, i.e. if A_c^-1A is an H-matrix, where A_c is the midpoint matrix of A`. For more details see section 4.6 of [HOR19].\n\nExamples\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> is_strongly_regular(A)\ntrue\n\njulia> A = [0..2 1..1;-1.. -1 0..2]\n2×2 Matrix{Interval{Float64}}:\n   [0, 2]  [1, 1]\n [-1, -1]  [0, 2]\n\njulia> is_strongly_regular(A)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"explanations/solution_set/#Solution-set-of-interval-linear-system","page":"Interval system solution set","title":"Solution set of interval linear system","text":"","category":"section"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"Pages=[\"solution_set.md\"]","category":"page"},{"location":"explanations/solution_set/#Interval-linear-systems","page":"Interval system solution set","title":"Interval linear systems","text":"","category":"section"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"An interval linear system is defined as","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"mathbfAmathbfx=mathbfb","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"where mathbfAinmathbbImathbbR^ntimes n and mathbfbinmathbbImathbbR^n are an interval matrix and vector, respectively.","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"The solution set  mathbfx is defined as","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"mathbfx = x in mathbbR^n  Ax=b text for some  AinmathbfA binmathbfb ","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"In other words, mathbfx is the set of solutions of the real linear systems Ax=b for some  AinmathbfA and binmathbfb. If the interval matrix mathbfA is regular, that is all AinmathbfA are invertible, then the solution set mathbfx will be non-empty and bounded. In general, checking for regularity of an interval matrix has exponential complexity.","category":"page"},{"location":"explanations/solution_set/#Solution-by-Monte-Carlo","page":"Interval system solution set","title":"Solution by Monte-Carlo","text":"","category":"section"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"A naive approach to solve an interval linear system would be to use Montecarlo, i.e. to randomly sample elements from the intervals and solve the several random real systems. Suppose we want to solve the linear system","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"beginbmatrix\n2 4-21\n-1 22 4\nendbmatrixmathbfx =\nbeginbmatrix\n-2 2\n-2 2\nendbmatrix","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"Since we are planning to solve several thousands of instances of the interval problem and we are working with small arrays, we can use StaticArrays.jl to speed up the computations.","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"using IntervalLinearAlgebra, StaticArrays \n\nA = @SMatrix [2..4 -2..1; -1..2 2..4]\nb = @SVector [-2..2, -2..2]\nnothing # hide","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"To perform Montecarlo, we need to sample from the intervals. This can be achieved using the rand function, for example ","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"rand(1..2)","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"we are now ready for our montecarlo simulation, let us solve 100000 random instances","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"N = 100000\n\nxs = [rand.(A)\\rand.(b) for _ in 1:N]\nnothing # hide","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"now we plot a 2D-histogram to inspect the distribution of the solutions.","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"using Plots\n\nx = [xs[i][1] for i in 1:N]\ny = [xs[i][2] for i in 1:N]\n\nhistogram2d(x, y, ratio=1)\nxlabel!(\"x\")\nylabel!(\"y\")\nsavefig(\"histogram-2d.png\") # hide","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"(Image: )","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"As we can see, most of the solutions seem to be condensed close to the origin, but repeating the experiments enough times we also got some solutions farther away, obtaining a star looking area. Now the question is, have we captured the whole solution set?","category":"page"},{"location":"explanations/solution_set/#Oettli-Präger-theorem","page":"Interval system solution set","title":"Oettli-Präger theorem","text":"","category":"section"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"The solution set mathbfx is exactly characterized by the Oettli-Präger theorem [OET64], which says that an interval linear system mathbfAmathbfx=mathbfb is equivalent to the set of real inequalities","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"A_cx-b_c le A_Deltax + b_Delta","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"where A_c and A_\\Delta are the midpoint and radius matrix of \\mathbf{A}, b_c and b_Delta are defined similarly. The absolute values are taken elementwise.","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"We have now transformed the set of interval equalities into a set of real inequalities. We can easily get rid of the absolute value on the left obtaining the system","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"begincases\nA_cx-b_c le A_Deltax + b_Delta\n-(A_cx-b_c) le A_Deltax + b_Delta\nendcases","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"We can remove the absolute value on the right by considering each orthant separately, obtaining 2^n linear inequalities, where n is the dimension of the problem.","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"Practically this means rewriting x=D_ex, where einpm 1^n and D_e is the diagonal matrix with e on the main diagonal. As there are 2^n possible instances of e, we will go through 2^n linear inequalities in the form","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"beginbmatrix\nA_c-A_Delta D_e\n-A_c-A_Delta D_e\nendbmatrixxle beginbmatrixb_Delta+b_cb_Delta-b_cendbmatrix","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"as this inequality is in the form tildeAxle tildeb its solution set will be a convex polytope. This has also an important theoretical consequence: the solution set of any interval linear system is composed by the union of 2^n convex polytopes (some possibly empty), each lying entirely in one orthant.","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"In IntervalLinearAlgebra.jl the polytopes composing the solution set can be found using the LinearOettliPrager() solver. Note that to use it you need to import LazySets.jl first.","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"using LazySets\n\npolytopes = solve(A, b, LinearOettliPrager())\n\nplot(polytopes, ratio=1, legend=:none)\nhistogram2d!(x, y)\nxlabel!(\"x\")\nylabel!(\"y\")\nsavefig(\"oettli.png\") # hide","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"(Image: )","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"As we can see, the original montecarlo approximation, despite the high number of iterations, could not cover the whole solution set.","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"Note also that the solution set is non-convex but is composed by 4 convex polygons, one in each orthant. This is a general property of interval linear systems. For example, let us consider the interval linear system","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"beginbmatrix\n45 450 20 2\n0 245 450 2\n0 20 2 45 45\nendbmatrixmathbfx=beginbmatrix-1 1\n-1 1\n-1 1endbmatrix","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"its solution set is depicted in the next picture.","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"(Image: )","category":"page"},{"location":"explanations/solution_set/#Disadvantages-of-Oettli-Präger","page":"Interval system solution set","title":"Disadvantages of Oettli-Präger","text":"","category":"section"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"As the number of orthants grows exponential with the dimension n, applying Oettli-Präger has exponential complexity and is thus practically unfeasible in higher dimensions. Moreover, also computing the interval hull of the solution set is NP-hard [ROH95]. For this reason, in practical applications polynomial time algorithms that return an interval enclosure of the solution set are used, although these may return an interval box strictly larger than the interval hull.","category":"page"},{"location":"api/solve/#General-inteface-for-solving-interval-linear-systems","page":"Solver interface","title":"General inteface for solving interval linear systems","text":"","category":"section"},{"location":"api/solve/","page":"Solver interface","title":"Solver interface","text":"solve","category":"page"},{"location":"api/solve/#CommonSolve.solve","page":"Solver interface","title":"CommonSolve.solve","text":"solve(A::AbstractMatrix{T},\n      b::AbstractVector{T},\n      solver::AbstractIterativeSolver,\n      [precondition]::AbstractPrecondition=_default_precondition(A, solver),\n      [X]::AbstractVector{T}=enclose(A, b)) where {T<:Interval}\n\nSolves the square interval system Ax=b using the given algorithm, preconditioner and initial enclosure\n\nInput\n\nA – square interval matrix\nb – interval vector\nsolver – algorithm used to solve the linear system\nprecondition – preconditioner used. If not given, it is automatically computed based on                   the matrix A and the solver.\nX – initial enclosure.        if not given, it is automatically computed using enclose\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> solve(A, b, GaussSeidel(), NoPrecondition(), [-10..10, -10..10])\n2-element Vector{Interval{Float64}}:\n [-1.66668, 1.66668]\n [-1.33334, 1.33334]\n\njulia> solve(A, b, GaussSeidel())\n2-element Vector{Interval{Float64}}:\n [-1.66667, 1.66667]\n [-1.33334, 1.33334]\n\n\n\n\n\nsolve(A::AbstractMatrix{T},\n      b::AbstractVector{T},\n      solver::AbstractDirectSolver,\n      [precondition]::AbstractPrecondition=_default_precondition(A, solver)) where\n      {T<:Interval}\n\nSolves the square interval system Ax=b using the given algorithm, preconditioner and initial enclosure\n\nInput\n\nA – square interval matrix\nb – interval vector\nsolver – algorithm used to solve the linear system\nprecondition – preconditioner used. If not given, it is automatically computed based on                   the matrix A and the solver.\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> solve(A, b, HansenBliekRohn(), InverseMidpoint())\n2-element Vector{Interval{Float64}}:\n [-1.66667, 1.66667]\n [-1.33334, 1.33334]\n\njulia> solve(A, b, HansenBliekRohn())\n2-element Vector{Interval{Float64}}:\n [-1.66667, 1.66667]\n [-1.33334, 1.33334]\n\n\n\n\n\nsolve(A::AbstractMatrix{T},\n      b::AbstractVector{T},\n      [solver]::AbstractLinearSolver,\n      [precondition]::AbstractPrecondition=_default_precondition(A, solver)) where\n      {T<:Interval}\n\nSolves the square interval system Ax=b using the given algorithm, preconditioner and initial enclosure\n\nInput\n\nA – square interval matrix\nb – interval vector\nsolver – algorithm used to solve the linear system. If not given,             GaussianElimination is used.\nprecondition – preconditioner used. If not given, it is automatically computed based on                   the matrix A and the solver.\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> solve(A, b)\n2-element Vector{Interval{Float64}}:\n [-1.66667, 1.66667]\n [-1.33334, 1.33334]\n\n\n\n\n\n","category":"function"},{"location":"api/epsilon_inflation/#Verified-real-linear-systems","page":"Verified real linear systems","title":"Verified real linear systems","text":"","category":"section"},{"location":"api/epsilon_inflation/","page":"Verified real linear systems","title":"Verified real linear systems","text":"Pages = [\"epsilon_inflation.md\"]","category":"page"},{"location":"api/epsilon_inflation/","page":"Verified real linear systems","title":"Verified real linear systems","text":"Modules = [IntervalLinearAlgebra]\nPages = [\"linear_systems/verify.jl\"]","category":"page"},{"location":"api/epsilon_inflation/#IntervalLinearAlgebra.epsilon_inflation-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractArray{S, N}}} where {T<:Real, S<:Real, N}","page":"Verified real linear systems","title":"IntervalLinearAlgebra.epsilon_inflation","text":"epsilon_inflation(A::AbstractMatrix{T}, b::AbstractArray{S, N};\n                  r=0.1, ϵ=1e-20, iter_max=20) where {T<:Real, S<:Real, N}\n\nepsilon_inflation(A::AbstractMatrix{T}, b::AbstractArray{S, N};\n                  r=0.1, ϵ=1e-20, iter_max=20) where {T<:Interval, S<:Interval, N}\n\nGives an enclosure of the solution of the square linear system Ax=b using the ϵ-inflation algorithm,  see algorithm 10.7 of [RUM10]\n\nInput\n\nA        – square matrix of size n × n\nb        – vector of length n or matrix of size n × m\nr        – relative inflation, default 10%\nϵ        – absolute inflation, default 1e-20\niter_max – maximum number of iterations\n\nOutput\n\nx    – enclosure of the solution of the linear system\ncert – Boolean flag, if cert==true, then x is certified to contain the true\n\nsolution of the linear system, if cert==false, then the algorithm could not prove that x actually contains the true solution.\n\nAlgorithm\n\nGiven the real system Ax=b and an approximate solution x, we initialize x₀ = x x. At each iteration the algorithm computes the inflation\n\ny = xₖ * 1 - r 1 + r + -ϵ ϵ\n\nand the update\n\nxₖ₁ = Z + (I - CA)y,\n\nwhere Z = C(b - Ax₀) and C is an approximate inverse of A. If the condition xₖ₁  y is met, then xₖ₁ is a proved enclosure of A¹b and cert is set to true. If the condition is not met by the maximum number of iterations, the latest computed enclosure is returned, but cert is set to false, meaning the algorithm could not prove that the enclosure contains the true solution. For interval systems, x is obtained considering the midpoint of A and b.\n\nNotes\n\nThis algorithm is meant for real linear systems, or interval systems with\n\nvery tiny intervals. For interval linear systems with wider intervals, see the solve function.\n\nExamples\n\njulia> A = [1 2;3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> b = A * ones(2)\n2-element Vector{Float64}:\n 3.0\n 7.0\n\njulia> x, cert = epsilon_inflation(A, b)\n(Interval{Float64}[[0.999999, 1.00001], [0.999999, 1.00001]], true)\n\njulia> ones(2) .∈ x\n2-element BitVector:\n 1\n 1\n\njulia> cert\ntrue\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: License: MIT)(Image: Build Status)(Image: Coverage)","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for IntervalLinearAlgebra.jl, a package for numerical linear algebra using interval arithmetic.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThe package is still under active development and everything can change overnight.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Different algorithms to enclose the solution of an interval linear system\nclassify interval matrices\nrigorous solution of real linear systems\nexact characterization of the solution of interval linear systems using Oettli-Präger","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is not registered yet, it can be installed as","category":"page"},{"location":"","page":"Home","title":"Home","text":"(@v1.6) pkg> add https://github.com/lucaferranti/intervallinearalgebra.jl","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using IntervalLinearAlgebra, LazySets, Plots\n\nA = [2..4 -1..1;-1..1 2..4]\nb = [-2..2, -1..1]\n\nXenclose = solve(A, b)\npolytopes = solve(A, b, LinearOettliPrager())\n\nplot(UnionSetArray(polytopes), ratio=1, label=\"solution set\", legend=:top)\nplot!(IntervalBox(Xenclose), label=\"enclosure\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: quickstart-example)","category":"page"},{"location":"api/algorithms/#Algorithms","page":"Interval linear systems","title":"Algorithms","text":"","category":"section"},{"location":"api/algorithms/","page":"Interval linear systems","title":"Interval linear systems","text":"Algorithms used to solve interval linear systems.","category":"page"},{"location":"api/algorithms/","page":"Interval linear systems","title":"Interval linear systems","text":"Pages=[\"algorithms.md\"]","category":"page"},{"location":"api/algorithms/#Enclosure-computation","page":"Interval linear systems","title":"Enclosure computation","text":"","category":"section"},{"location":"api/algorithms/#Direct-methods","page":"Interval linear systems","title":"Direct methods","text":"","category":"section"},{"location":"api/algorithms/","page":"Interval linear systems","title":"Interval linear systems","text":"GaussianElimination\nHansenBliekRohn","category":"page"},{"location":"api/algorithms/#IntervalLinearAlgebra.GaussianElimination","page":"Interval linear systems","title":"IntervalLinearAlgebra.GaussianElimination","text":"GaussianElimination <: AbstractDirectSolver\n\nType for the Gaussian elimination solver of the square interval linear system Ax=b. For more details see section 5.6.1 of [HOR19]\n\nNotes\n\nAn object of type GaussianElimination is a callable function with method\n  (ge::GaussianElimination)(A::AbstractMatrix{T},\n                            b::AbstractVector{T}) where {T<:Interval}\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> ge = GaussianElimination()\nGaussianElimination linear solver\n\njulia> ge(A, b)\n2-element Vector{Interval{Float64}}:\n [-1.66667, 1.66667]\n [-1.33334, 1.33334]\n\n\n\n\n\n","category":"type"},{"location":"api/algorithms/#IntervalLinearAlgebra.HansenBliekRohn","page":"Interval linear systems","title":"IntervalLinearAlgebra.HansenBliekRohn","text":"HansenBliekRohn <: AbstractDirectSolver\n\nType for the HansenBliekRohn solver of the square interval linear system Ax=b. For more details see section 5.6.2 of [HOR19]\n\nNotes\n\nHansen-Bliek-Rohn works with H-matrices without precondition and with strongly regular matrices using InverseMidpoint precondition\nIf the midpoint of A is a diagonal matrix, then the algorithm returns the exact hull.\nAn object of type Hansen-Bliek-Rohn is a callable function with method\n  (hbr::HansenBliekRohn)(A::AbstractMatrix{T},\n                         b::AbstractVector{T}) where {T<:Interval}\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> hbr = HansenBliekRohn()\nHansenBliekRohn linear solver\n\njulia> hbr(A, b)\n2-element Vector{Interval{Float64}}:\n [-1.66667, 1.66667]\n [-1.33334, 1.33334]\n\n\n\n\n\n","category":"type"},{"location":"api/algorithms/#Iterative-methods","page":"Interval linear systems","title":"Iterative methods","text":"","category":"section"},{"location":"api/algorithms/","page":"Interval linear systems","title":"Interval linear systems","text":"GaussSeidel\nJacobi\nLinearKrawczyk","category":"page"},{"location":"api/algorithms/#IntervalLinearAlgebra.GaussSeidel","page":"Interval linear systems","title":"IntervalLinearAlgebra.GaussSeidel","text":"GaussSeidel <: AbstractIterativeSolver\n\nType for the Gauss-Seidel solver of the interval linear system Ax=b. For details see Section 5.7.4 of [HOR19]\n\nFields\n\nmax_iterations – maximum number of iterations (default 20)\natol           – absolute tolerance (default 0), if at some point xₖ - xₖ₁  atol                     (elementwise), then stop and return xₖ₁.                     If atol=0, then min(diam(A))*1e-5 is used.\n\nNotes\n\nAn object of type GaussSeidel is a function with method\n  (gs::GaussSeidel)(A::AbstractMatrix{T},\n                    b::AbstractVector{T},\n                    [x]::AbstractVector{T}=enclose(A, b)) where {T<:Interval}\nInput\nA   – N×N interval matrix\nb   – interval vector of length N\nx   – (optional) initial enclosure for the solution of Ax = b. If not given,          it is automatically computed using enclose\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> gs = GaussSeidel()\nGaussSeidel linear solver\nmax_iterations = 20\natol = 0.0\n\njulia> gs(A, b)\n2-element Vector{Interval{Float64}}:\n [-1.66668, 1.66668]\n [-1.33334, 1.33334]\n\n\n\n\n\n","category":"type"},{"location":"api/algorithms/#IntervalLinearAlgebra.Jacobi","page":"Interval linear systems","title":"IntervalLinearAlgebra.Jacobi","text":"Jacobi <: AbstractIterativeSolver\n\nType for the Jacobi solver of the interval linear system Ax=b. For details see Section 5.7.4 of [HOR19]\n\nFields\n\nmax_iterations – maximum number of iterations (default 20)\natol           – absolute tolerance (default 0), if at some point xₖ - xₖ₁  atol                     (elementwise), then stop and return xₖ₁.                     If atol=0, then min(diam(A))*1e-5 is used.\n\nNotes\n\nAn object of type Jacobi is a function with method\n  (jac::Jacobi)(A::AbstractMatrix{T},\n                b::AbstractVector{T},\n                [x]::AbstractVector{T}=enclose(A, b)) where {T<:Interval}\nInput\nA   – N×N interval matrix\nb   – interval vector of length N\nx   – (optional) initial enclosure for the solution of Ax = b. If not given,          it is automatically computed using enclose\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> jac = Jacobi()\nJacobi linear solver\nmax_iterations = 20\natol = 0.0\n\njulia> jac(A, b)\n2-element Vector{Interval{Float64}}:\n [-1.66668, 1.66668]\n [-1.33335, 1.33335]\n\n\n\n\n\n","category":"type"},{"location":"api/algorithms/#IntervalLinearAlgebra.LinearKrawczyk","page":"Interval linear systems","title":"IntervalLinearAlgebra.LinearKrawczyk","text":"LinearKrawczyk <: AbstractIterativeSolver\n\nType for the Krawczyk solver of the interval linear system Ax=b. For details see Section 5.7.3 of [HOR19]\n\nFields\n\nmax_iterations – maximum number of iterations (default 20)\natol           – absolute tolerance (default 0), if at some point xₖ - xₖ₁  atol                     (elementwise), then stop and return xₖ₁.                     If atol=0, then min(diam(A))*1e-5 is used.\n\nNotes\n\nAn object of type LinearKrawczyk is a function with method\n  (kra::LinearKrawczyk)(A::AbstractMatrix{T},\n                        b::AbstractVector{T},\n                        [x]::AbstractVector{T}=enclose(A, b)) where {T<:Interval}\nInput\nA   – N×N interval matrix\nb   – interval vector of length N\nx   – (optional) initial enclosure for the solution of Ax = b. If not given,          it is automatically computed using enclose\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> kra = LinearKrawczyk()\nLinearKrawczyk linear solver\nmax_iterations = 20\natol = 0.0\n\njulia> kra(A, b)\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-2, 2]\n\n\n\n\n\n","category":"type"},{"location":"api/algorithms/#Exact-characterization","page":"Interval linear systems","title":"Exact characterization","text":"","category":"section"},{"location":"api/algorithms/","page":"Interval linear systems","title":"Interval linear systems","text":"LinearOettliPrager\nNonLinearOettliPrager","category":"page"},{"location":"api/algorithms/#IntervalLinearAlgebra.LinearOettliPrager","page":"Interval linear systems","title":"IntervalLinearAlgebra.LinearOettliPrager","text":"LinearOettliPrager <: AbstractDirectSolver\n\nType for the OettliPrager solver of the interval linear system Ax=b. The solver first converts the system of interval equalities into a system of real inequalities using Oettli-Präger theorem [OET64] and then finds the feasible set by solving a LP problem in each orthant using LazySets.jl.\n\nNotes\n\nYou need to import LazySets.jl to use this functionality.\nAn object of type LinearOettliPrager is a function with methods\n  (op::LinearOettliPrager)(A::AbstractMatrix{T},\n                           b::AbstractVector{T}) where {T<:Interval}\nInput\nA   – N×N interval matrix\nb   – interval vector of length N\n\nExamples\n\njulia> A = [2..4 -2..1;-1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> b = [-2..2, -2..2]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-2, 2]\n\njulia> polytopes = solve(A, b, LinearOettliPrager());\n\njulia> typeof(polytopes)\nVector{HPolytope{Float64, SparseArrays.SparseVector{Float64, Int64}}}\n\n\n\n\n\n","category":"type"},{"location":"api/algorithms/#IntervalLinearAlgebra.NonLinearOettliPrager","page":"Interval linear systems","title":"IntervalLinearAlgebra.NonLinearOettliPrager","text":"NonLinearOettliPrager <: AbstractIterativeSolver\n\nType for the OettliPrager solver of the interval linear system Ax=b. The solver first converts the system of interval equalities into a system of real inequalities using Oettli-Präger theorem [OET64] and then finds the feasible set using the forward-backward contractor method [JAU14] implemented in IntervalConstraintProgramming.jl.\n\nFields\n\ntol – tolerance for the paving, default 0.01.\n\nNotes\n\nYou need to import IntervalConstraintProgramming.jl to use this functionality.\nAn object of type NonLinearOettliPrager is a function with methods\n  (op::NonLinearOettliPrager)(A::AbstractMatrix{T},\n                              b::AbstractVector{T},\n                              [X]::AbstractVector{T}=enclose(A, b)) where {T<:Interval}\n\n  (op::NonLinearOettliPrager)(A::AbstractMatrix{T},\n                              b::AbstractVector{T},\n                              X::IntervalBox) where {T<:Interval}\nInput\nA   – N×N interval matrix\nb   – interval vector of length N\nX   – (optional) initial enclosure for the solution of Ax = b. If not given,          it is automatically computed using enclose\n\nExamples\n\njulia> A = [2..4 -2..1;-1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> b = [-2..2, -2..2]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-2, 2]\n\njulia> solve(A, b, NonLinearOettliPrager(0.1))\nPaving:\n- tolerance ϵ = 0.1\n- inner approx. of length 1195\n- boundary approx. of length 823\n\n\n\n\n\n","category":"type"}]
}
